<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Measurement App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    
</head>

<body>

    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Ball Localization App</h1>

        <div class="message-box" id="messageBox"></div>

        <div class="video-container">
            <video id="webcamFeed" autoplay playsinline></video>
            <canvas id="measurementCanvas"></canvas>
        </div>

        <div class="controls">
            <button id="cameraActionBtn" class="btn-primary">Start Camera</button>
            <button id="selectCenterBtn" class="btn-secondary" disabled>Select Center</button>
            <button id="measureDiameterBtn" class="btn-secondary" disabled>Measure Diameter</button>
            <button id="saveMeasurementBtn" class="btn-primary" disabled>Save Measurement</button>
            <button id="localizeBallBtn" class="btn-primary" disabled>Localize Ball (3D)</button>
            <button id="resetBtn" class="btn-danger">Reset</button>
        </div>

        <div class="data-display mt-4">
            <div class="data-item">Center X (px): <span id="centerXDisplay">N/A</span></div>
            <div class="data-item">Center Y (px): <span id="centerYDisplay">N/A</span></div>
            <div class="data-item">Diameter (px): <span id="diameterDisplay">N/A</span></div>
            <div class="data-item">Ball X (cm): <span id="ballXDisplay">N/A</span></div>
            <div class="data-item">Ball Y (cm): <span id="ballYDisplay">N/A</span></div>
            <div class="data-item">Ball Z (cm): <span id="ballZDisplay">N/A</span></div>
        </div>
    </div>

    <script>

const webcamFeed = document.getElementById('webcamFeed');
const measurementCanvas = document.getElementById('measurementCanvas');
const ctx = measurementCanvas.getContext('2d');

const cameraActionBtn = document.getElementById('cameraActionBtn');
const selectCenterBtn = document.getElementById('selectCenterBtn');
const measureDiameterBtn = document.getElementById('measureDiameterBtn');
const saveMeasurementBtn = document.getElementById('saveMeasurementBtn');
const localizeBallBtn = document.getElementById('localizeBallBtn');
const resetBtn = document.getElementById('resetBtn');

const centerXDisplay = document.getElementById('centerXDisplay');
const centerYDisplay = document.getElementById('centerYDisplay');
const diameterDisplay = document.getElementById('diameterDisplay');
const ballXDisplay = document.getElementById('ballXDisplay');
const ballYDisplay = document.getElementById('ballYDisplay');
const ballZDisplay = document.getElementById('ballZDisplay');
const messageBox = document.getElementById('messageBox');

let stream;
let capturedImageBlob = null;
let capturedImageFilename = null;
let drawingMode = null;
let centerPoint = null;
let diameterEndPoint = null;
let cameraActive = false;
let capturedImageData = null;

// Function to display messages to the user
function showMessage(message, type = 'success') {
    messageBox.textContent = message;
    messageBox.className = 'message-box';
    if (type === 'success') {
        messageBox.classList.add('bg-green-100', 'text-green-800');
    } else if (type === 'error') {
        messageBox.classList.add('bg-red-100', 'text-red-800');
    } else if (type === 'info') {
        messageBox.classList.add('bg-blue-100', 'text-blue-800');
    }
    messageBox.style.display = 'block';
    setTimeout(() => {
        messageBox.style.display = 'none';
    }, 5000);
}

// Function to resize canvas to match video dimensions
function resizeCanvas() {
    if (webcamFeed.videoWidth && webcamFeed.videoHeight) {
        measurementCanvas.width = webcamFeed.videoWidth;
        measurementCanvas.height = webcamFeed.videoHeight;
        
        // Set canvas display size to match video
        const rect = webcamFeed.getBoundingClientRect();
        measurementCanvas.style.width = rect.width + 'px';
        measurementCanvas.style.height = rect.height + 'px';
    }
}

// Initial button state
cameraActionBtn.disabled = false;
selectCenterBtn.disabled = true;
measureDiameterBtn.disabled = true;
saveMeasurementBtn.disabled = true;
localizeBallBtn.disabled = true;
resetBtn.disabled = false;

// Camera action button logic
cameraActionBtn.addEventListener('click', async () => {
    if (!cameraActive) {
        // Start camera
        try {
    stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
        facingMode: { exact: "environment" },
        width: { exact: 3000 },
        height: { exact: 4000 }
    } 
});
            webcamFeed.srcObject = stream;
            
            webcamFeed.onloadedmetadata = () => {
                resizeCanvas();
                cameraActionBtn.textContent = 'Capture Image';
                cameraActive = true;
                showMessage("Camera started. Click 'Capture Image' to take a photo.", "info");
            };
            
            webcamFeed.addEventListener('resize', resizeCanvas);
            window.addEventListener('resize', resizeCanvas);
            
        } catch (err) {
            console.error("Error accessing camera: ", err);
            showMessage("Error accessing camera. Please ensure camera access is granted.", "error");
        }
    } else {
        // Capture image
        //resizeCanvas();
        
        ctx.drawImage(webcamFeed, 0, 0, measurementCanvas.width, measurementCanvas.height);
        
        capturedImageData = ctx.getImageData(0, 0, measurementCanvas.width, measurementCanvas.height);
        
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            webcamFeed.srcObject = null;
            stream = null;
        }
        
        measurementCanvas.toBlob(async (blob) => {
            capturedImageBlob = blob;
            const reader = new FileReader();
            reader.onloadend = async () => {
                try {
                    const response = await fetch('/upload_image', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ image: reader.result })
                    });
                    const result = await response.json();
                    if (result.success) {
                        capturedImageFilename = result.filename;
                        showMessage("Image captured and saved. Now select the ball's center.", "info");
                        
                        cameraActionBtn.textContent = 'Start Camera';
                        cameraActionBtn.disabled = false;
                        selectCenterBtn.disabled = false;
                        measureDiameterBtn.disabled = true;
                        saveMeasurementBtn.disabled = true;
                        localizeBallBtn.disabled = true;
                        
                        cameraActive = false;
                        
                        drawCanvas();
                        
                    } else {
                        showMessage(result.message, 'error');
                    }
                } catch (error) {
                    console.error('Error uploading image:', error);
                    showMessage('Failed to upload image.', 'error');
                }
            };
            reader.readAsDataURL(blob);
        }, 'image/jpeg');
    }
});

// Select Center Mode
selectCenterBtn.addEventListener('click', () => {
    if (!capturedImageData) {
        showMessage("Capture an image first!", "error");
        return;
    }
    drawingMode = 'center';
    showMessage("Click on the ball's center.", "info");
});

// Measure Diameter Mode
measureDiameterBtn.addEventListener('click', () => {
    if (!centerPoint) {
        showMessage("Please select the ball's center first.", "error");
        return;
    }
    drawingMode = 'diameter';
    showMessage("Click on the ball's circumference to measure diameter.", "info");
});

// Canvas Click Listener for drawing
measurementCanvas.addEventListener('click', (e) => {
    if (!drawingMode || !capturedImageData) return;

    const rect = measurementCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const scaleX = measurementCanvas.width / rect.width;
    const scaleY = measurementCanvas.height / rect.height;
    const actualX = x * scaleX;
    const actualY = y * scaleY;

    if (drawingMode === 'center') {
        centerPoint = { x: actualX, y: actualY };
        centerXDisplay.textContent = Math.round(actualX);
        centerYDisplay.textContent = Math.round(actualY);
        drawCanvas();
        drawingMode = null;
        
        measureDiameterBtn.disabled = false;
        showMessage("Center selected. Now measure the diameter.", "info");
        
    } else if (drawingMode === 'diameter') {
        diameterEndPoint = { x: actualX, y: actualY };
        if (centerPoint) {
            const radius = Math.sqrt(
                Math.pow(diameterEndPoint.x - centerPoint.x, 2) +
                Math.pow(diameterEndPoint.y - centerPoint.y, 2)
            );
            const diameter = radius * 2;
            diameterDisplay.textContent = Math.round(diameter);
            drawCanvas();
            drawingMode = null;
            
            saveMeasurementBtn.disabled = false;
            localizeBallBtn.disabled = false;
            showMessage("Diameter measured. Click 'Save Measurement' or 'Localize Ball (3D)'.", "info");
        }
    }
});

// Draw function to update canvas
function drawCanvas() {
    ctx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);

    if (capturedImageData) {
        ctx.putImageData(capturedImageData, 0, 0);
        drawMeasurements();
    }
}

// Draw measurements (center, diameter circle)
function drawMeasurements() {
    if (centerPoint) {
        ctx.beginPath();
        ctx.arc(centerPoint.x, centerPoint.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.closePath();

        if (diameterEndPoint) {
            const radius = Math.sqrt(
                Math.pow(diameterEndPoint.x - centerPoint.x, 2) +
                Math.pow(diameterEndPoint.y - centerPoint.y, 2)
            );
            ctx.beginPath();
            ctx.arc(centerPoint.x, centerPoint.y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }
    }
}

// Save Measurement
saveMeasurementBtn.addEventListener('click', async () => {
    if (!centerPoint || diameterDisplay.textContent === 'N/A' || !capturedImageFilename) {
        showMessage("Please capture an image, select center, and measure diameter first.", "error");
        return;
    }

    const diameter = parseFloat(diameterDisplay.textContent);
    const ballX = ballXDisplay.textContent === 'N/A' ? null : parseFloat(ballXDisplay.textContent);
    const ballY = ballYDisplay.textContent === 'N/A' ? null : parseFloat(ballYDisplay.textContent);
    const ballZ = ballZDisplay.textContent === 'N/A' ? null : parseFloat(ballZDisplay.textContent);

    try {
        const response = await fetch('/save_measurement', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                centerX: Math.round(centerPoint.x),
                centerY: Math.round(centerPoint.y),
                diameter: Math.round(diameter),
                imageFilename: capturedImageFilename,
                ballX: ballX, // Include 3D coordinates
                ballY: ballY,
                ballZ: ballZ
            })
        });
        const result = await response.json();
        if (result.success) {
            showMessage(result.message);
            saveMeasurementBtn.disabled = true;
        } else {
            showMessage(result.message, 'error');
        }
    } catch (error) {
        console.error('Error saving measurement:', error);
        showMessage('Failed to save measurement.', 'error');
    }
});

// Localize Ball (3D) button logic
localizeBallBtn.addEventListener('click', async () => {
    if (!centerPoint || diameterDisplay.textContent === 'N/A') {
        showMessage("Please select ball center and measure diameter first.", "error");
        return;
    }

    const centerX = Math.round(centerPoint.x);
    const centerY = Math.round(centerPoint.y);
    const diameter = parseFloat(diameterDisplay.textContent);

    try {
        showMessage("Localizing ball in 3D...", "info");
        const response = await fetch('/ball_localization', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                centerX: centerX,
                centerY: centerY,
                diameter: diameter
            })
        });
        const result = await response.json();

        if (result.success) {
            const { x, y, z } = result.ball_position_camera_coords;
            ballXDisplay.textContent = x.toFixed(2);
            ballYDisplay.textContent = y.toFixed(2);
            ballZDisplay.textContent = z.toFixed(2);
            showMessage("Ball localized successfully!", "success");
        } else {
            showMessage(result.message, 'error');
            ballXDisplay.textContent = 'N/A';
            ballYDisplay.textContent = 'N/A';
            ballZDisplay.textContent = 'N/A';
        }
    } catch (error) {
        console.error('Error localizing ball:', error);
        showMessage('Failed to localize ball in 3D.', 'error');
        ballXDisplay.textContent = 'N/A';
        ballYDisplay.textContent = 'N/A';
        ballZDisplay.textContent = 'N/A';
    }
});

// Reset
resetBtn.addEventListener('click', () => {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
    }
    
    webcamFeed.srcObject = null;
    
    ctx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
    
    capturedImageBlob = null;
    capturedImageFilename = null;
    capturedImageData = null;
    drawingMode = null;
    centerPoint = null;
    diameterEndPoint = null;
    cameraActive = false;
    
    centerXDisplay.textContent = 'N/A';
    centerYDisplay.textContent = 'N/A';
    diameterDisplay.textContent = 'N/A';
    ballXDisplay.textContent = 'N/A';
    ballYDisplay.textContent = 'N/A';
    ballZDisplay.textContent = 'N/A';
    
    cameraActionBtn.textContent = 'Start Camera';
    cameraActionBtn.disabled = false;
    selectCenterBtn.disabled = true;
    measureDiameterBtn.disabled = true;
    saveMeasurementBtn.disabled = true;
    localizeBallBtn.disabled = true;
    resetBtn.disabled = false;
    
    showMessage("Application reset. Click 'Start Camera' to begin.", "info");
});

    </script>
</body>
</html>
